// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.24;

// libraries
import {Strings} from "@openzeppelin/contracts@5.0.2/utils/Strings.sol";
import {MerkleProof} from "@openzeppelin/contracts@5.0.2/utils/cryptography/MerkleProof.sol";

// inherits
import {Ownable, Ownable2Step} from "@openzeppelin/contracts@5.0.2/access/Ownable2Step.sol";
import {ERC721} from "@openzeppelin/contracts@5.0.2/token/ERC721/ERC721.sol";

/// @param rank: The rank of the token based on Llama Quest result
/// @param questId: The Id of Llama Quest
/// @param root: The merkle root of the token
struct TokenData {
    uint24 rank;
    uint8 questId;
    bytes32 root;
}

/// @notice Leaf information for the merkle tree to redeem token
/// @dev Node hash = keccak256(keccak256(abi.encode(account, rank, questId)))
struct LeafInfo {
    address account;
    uint24 rank;
    uint8 questId;
}

contract LlamaRaceDrop is ERC721, Ownable2Step {
    /// @dev Merkle root => Base Metadata URI like https://ipfs.io/ipfs/<CID> or ipfs://<CID>
    mapping(bytes32 root => string metadataURI) public s_roots;

    /// @dev TokenId => data (Llama quest number, rank, mekle root)
    mapping(uint256 tokenId => TokenData) internal s_tokenData;

    constructor(address _owner) ERC721(name(), symbol()) Ownable(_owner) {}

    error MerkleRootAlreadyExists();
    error MerkleRootDoesNotExist();
    error InvalidMerkleProof();
    error TokenAlreadyMinted();
    error EmptyURI();

    /// @notice Redeem token by providing leaf information and merkle proof
    /// @dev TokenId is not sequential, it is generated by semi-randomly hashing leaf information
    function redeem(LeafInfo calldata leafInfo, bytes32[] calldata proof, bytes32 root) external returns (uint256) {
        bytes32 leafHash = getLeaf(leafInfo); // Get node hash
        if (!_rootExists(root)) revert MerkleRootDoesNotExist();
        if (!MerkleProof.verify(proof, root, leafHash)) {
            revert InvalidMerkleProof();
        }

        uint256 tokenId = getTokenId(leafInfo, root); // Generate unique tokenId
        if (_ownerOf(tokenId) != address(0)) revert TokenAlreadyMinted();

        s_tokenData[tokenId] = TokenData({rank: leafInfo.rank, questId: leafInfo.questId, root: root});
        _mint(leafInfo.account, tokenId);

        return tokenId;
    }

    /// @param info Leaf information
    /// @return Node hash
    function getLeaf(LeafInfo memory info) public pure returns (bytes32) {
        return keccak256(bytes.concat(keccak256(abi.encode(info.account, info.rank, info.questId))));
    }

    /// @param baseMetadataURI: Base URI for the metadata of the token
    /// Note: Be careful with the baseMetadataURI, it should be ended with `/`.
    function addNewRoot(bytes32 root, string memory baseMetadataURI) public onlyOwner {
        if (_rootExists(root)) revert MerkleRootAlreadyExists();
        if (bytes(baseMetadataURI).length == 0) revert EmptyURI();

        s_roots[root] = baseMetadataURI;
    }

    function _rootExists(bytes32 root) internal view returns (bool) {
        return bytes(s_roots[root]).length > 0;
    }

    /// @notice Get unique tokenId for a leaf
    /// @dev The function doesn't revert if `root` or `info` doesn't exist
    function getTokenId(LeafInfo calldata info, bytes32 root) public pure returns (uint256) {
        return uint256(keccak256(abi.encode(info.account, info.rank, info.questId, root)));
    }

    /// @dev URI: Picture of a `tokenId` with a rank of `rank` will be stored at <baseURI><rank>.json
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        _requireOwned(tokenId);

        string memory baseURI = s_roots[s_tokenData[tokenId].root];
        return string.concat(baseURI, Strings.toString(uint256(s_tokenData[tokenId].rank)), ".json");
    }

    function getTokenData(uint256 tokenId) public view returns (TokenData memory) {
        _requireOwned(tokenId);
        return s_tokenData[tokenId];
    }

    function name() public pure override returns (string memory) {
        return "Llama Race Drop";
    }

    function symbol() public pure override returns (string memory) {
        return "LlamaRaceDrop";
    }
}
